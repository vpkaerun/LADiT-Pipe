import logging
import re
from pathlib import Path
from typing import Dict, List, Any

import torch
import whisper

# ロガー設定
logger = logging.getLogger(__name__)


def transcribe_chunk(
    audio_file: Path,
    diarization: Any,
    whisper_model: whisper.Whisper,
    min_speakers: int,
    max_speakers: int,
) -> str:
    """
    指定された音声チャンクに対してWhisperモデルで文字起こしを実行します。

    Args:
        audio_file (Path): 文字起こしを行う音声チャンクのファイルパス。
        diarization (Any): 話者分離結果 (pyannote.core.Annotationオブジェクトを想定)。
        whisper_model (whisper.Whisper): ロード済みのWhisperモデルオブジェクト。
        min_speakers (int): 最小話者数 (transcribe_chunk内では直接使用されないが、引数として保持)。
        max_speakers (int): 最大話者数 (transcribe_chunk内では直接使用されないが、引数として保持)。

    Returns:
        str: 文字起こし結果のテキスト。エラー発生時や結果が空の場合は空文字を返します。
    """
    try:
        # GPU メモリ管理
        if torch.cuda.is_available():
            torch.cuda.empty_cache()

        # Whisperのオプション設定（繰り返し抑制・高精度化）
        options = {
            "language": "ja",  # 日本語指定
            "task": "transcribe",
            "fp16": True,  # 高速化
            "temperature": 0.0,  # 決定的な出力
            "best_of": 1,  # 高速化
            "beam_size": 1,  # 高速化
            "patience": 1.0,
            "repetition_penalty": 1.2,  # 繰り返しペナルティ
            "suppress_tokens": [-1],  # 不要なトークンを抑制
            "compression_ratio_threshold": 2.4,  # 圧縮率による品質チェック
            "logprob_threshold": -1.0,  # 低確率出力の抑制
            "condition_on_previous_text": False,  # 前のテキストに依存しない
        }

        result = whisper_model.transcribe(str(audio_file), **options)

        # テキストを直接返し、空の場合は空文字を返す
        return result.get("text", "").strip()
    except Exception as e:
        logger.error(f"文字起こしエラー {audio_file}: {e}")
        return ""


def _post_process_transcription(segments: List[Dict]) -> List[Dict]:
    """
    転写結果の後処理を行い、繰り返しパターンや意味のないセグメントを除去します。

    Args:
        segments (List[Dict]): Whisperモデルからの生の文字起こし結果のセグメントリスト。

    Returns:
        List[Dict]: 後処理された文字起こし結果のセグメントリスト。
    """
    processed_segments = []
    for segment in segments:
        text = segment["text"].strip()
        if not text:
            continue

        # 繰り返しパターンの除去
        text = _remove_repetitions(text)

        # 意味のないセグメントの除去
        if _is_meaningless_segment(text):
            continue

        processed_segments.append(
            {"start": segment["start"], "end": segment["end"], "text": text}
        )
    return processed_segments


def _remove_repetitions(text: str) -> str:
    """
    テキスト内の繰り返しパターンを除去します。

    Args:
        text (str): 処理対象のテキスト。

    Returns:
        str: 繰り返しパターンが除去されたテキスト。
    """
    # 例: "あああああ" -> "あ"
    text = re.sub(r"(.)\1{3,}", r"\1", text)
    # 例: "はいはいはい" -> "はい"
    text = re.sub(r"(.{2,})\1{2,}", r"\1", text)
    return text


def _is_meaningless_segment(text: str) -> bool:
    """
    セグメントのテキストが意味のない内容（例: 笑い声、咳払い）であるかを判定します。

    Args:
        text (str): 判定対象のテキスト。

    Returns:
        bool: 意味のない内容であればTrue、そうでなければFalse。
    """
    meaningless_patterns = [
        r"^\s*(\(?(笑い|笑|咳|えー|あー|うーん|んー|ふーん|はい|ええ|うん|あ|え|う|お|ん)"
        r"\)?\s*){2,}\s*$",
        r"^\s*(\[?(laughter|laugh|cough|uhm|uh|hmm|yeah|yes|oh|ah|er|um|mm|mhm)\]?\s*){2,}\s*$",
        r"^\s*(\[音楽\]|\[Music\]|\[拍手\]|\[Applause\])\s*$",
        r"^\s*(\.\s*){3,}\s*$",  # ... の繰り返し
        r"^\s*(\?+\s*){2,}\s*$",  # ?? の繰り返し
        r"^\s*(\!+\s*){2,}\s*$",  # !! の繰り返し
        r"^\s*(\s*){10,}\s*$",  # 10文字以上の空白
    ]
    for pattern in meaningless_patterns:
        if re.fullmatch(pattern, text, re.IGNORECASE):
            return True
    return False
